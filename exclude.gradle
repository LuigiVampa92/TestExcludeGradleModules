// todo !! убедиться что сборка идёт на машине разработчика !! параметр или специальный файл
// todo log debug !
// todo try to compile and make sure stubs work

def modulesToExcludeFromHandling = [ ':', ':app' ]
def featureModuleSuffix = 'impl'
def stubSuffixes = [ 'noop', 'stub' ]

def excludeProjectsByPaths(projectsSet, excludePathsSet) {
    def result = new HashSet<Project>(projectsSet)
    def iterator = result.iterator()
    while (iterator.hasNext()) {
        def project = iterator.next()
        for (excludedPath in excludePathsSet) {
            if (excludedPath == project.path) {
                iterator.remove()
            }
        }
    }
    return (Set<Project>) result
}

def flattenProjects(complexProject) {
    HashSet<Project> result = new HashSet<>()
    if (complexProject.hasProperty("children")) {
        def childrenPaths = complexProject.properties.get("children")
        if (childrenPaths.size() > 0) {
            for (childProjectPath in childrenPaths) {
                try {
                    def childProject = project("$childProjectPath")
                    result.addAll(flattenProjects(childProject))
                } catch (Throwable ignored) {
                }
            }
        } else {
            result.add(complexProject)
        }
    } else {
        result.add(complexProject)
    }
    return (Set<Project>) result
}

def getProjectStubDir(inspectedProject, featureModuleSuffix, stubSuffixes) {
    def shortName = inspectedProject.name
    def inspectedDir = inspectedProject.projectDir.getParentFile()
    for (stubSuffix in stubSuffixes) {
        if (shortName == featureModuleSuffix) {
            def f = new File(inspectedDir, stubSuffix)
            if (f != null && f.exists() && f.isDirectory()) {
                def buildScriptFile = new File(f, "build.gradle")
                if (buildScriptFile != null && buildScriptFile.exists() && !buildScriptFile.isDirectory()) {
                    return f
                }
            }
        }
        else if ("$shortName".endsWith("-$featureModuleSuffix")) {
            def prefix = shortName.substring(0, shortName.indexOf("-$featureModuleSuffix"))
            def newName = prefix + "-$stubSuffix"
            def f = new File(inspectedDir, newName)
            if (f != null && f.exists() && f.isDirectory()) {
                def buildScriptFile = new File(f, "build.gradle")
                if (buildScriptFile != null && buildScriptFile.exists() && !buildScriptFile.isDirectory()) {
                    return f
                }
            }
        }
        else {
            def f = new File(inspectedDir, "$shortName-$stubSuffix")
            if (f != null && f.exists() && f.isDirectory()) {
                def buildScriptFile = new File(f, "build.gradle")
                if (buildScriptFile != null && buildScriptFile.exists() && !buildScriptFile.isDirectory()) {
                    return f
                }
            }
        }
    }
    return null
}

def projects = excludeProjectsByPaths(flattenProjects(rootProject), modulesToExcludeFromHandling)
projects.forEach {
    def stubDir = getProjectStubDir(it, featureModuleSuffix, stubSuffixes)
    if (stubDir != null) {
        println("For module [${it.path}] assigned a stub [$stubDir]")
        it.projectDir = stubDir
    }
}




//println("PROJECT NAME: ${rootProject.name}")
//println("PROJECT DIR: ${rootProject.getProjectDir()}")
//println("PROJECT PROPERTIES:")
//println(rootProject.properties)

//File excludePropertiesFile = new File("exclude_simple_replace_project_dir.properties")
//if (excludePropertiesFile.exists()) {
//    println("exclude properties configs file EXISTS")
//    Properties excludeProperties = new Properties()
//    excludeProperties.load(excludePropertiesFile.newDataInputStream())
//    excludeProperties.putAll(excludePropertiesMap)
//    excludeProperties.stringPropertyNames().forEach {
//        excludePropertiesMap.put(it, excludeProperties.getProperty(it))
//    }
//} else {
//    println("exclude properties configs file does NOT exist")
//}
//
//for (entry in excludePropertiesMap) {
////    println("[${entry.key}] -> [${entry.value}]")
//    project(":${entry.key}").projectDir = new File("${entry.value}")
//}
